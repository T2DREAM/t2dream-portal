{"name":"deep-equal-ident","version":"1.1.1","description":"A function to test for identical deep equality (based on lodash's isEqual).","main":"index.js","scripts":{"test":"jest"},"keywords":["lodash","equality","deep","chai","testing"],"author":{"name":"Felix Kling"},"license":"MIT","dependencies":{"lodash.isequal":"^3.0"},"devDependencies":{"chai":"^3.0.0","jest-cli":"^0.5.8"},"repository":{"type":"git","url":"git+ssh://git@github.com/fkling/deep-equal-ident.git"},"homepage":"https://github.com/fkling/deep-equal-ident","bugs":{"url":"https://github.com/fkling/deep-equal-ident/issues"},"readme":"## Deep comparison with object identity checks  [![Build Status](https://travis-ci.org/fkling/deep-equal-ident.svg?branch=master)](https://travis-ci.org/fkling/deep-equal-ident)\n\n\nThis function performs a deep comparison between the two values `a` and `b`. It\nhas the same signature and functionality as [lodash's isEqual function](http://lodash.com/docs#isEqual),\nwith one difference: It also tracks the identity of nested objects.\n\nThis function is intended to be used for unit tests (see below how to use it\nwith chai.js).\n\n### Installation\n\n    npm install -S deep-equal-ident\n\nand use it as\n\n```javascript\nvar deepEqualIdent = require('deep-equal-ident');\n// ...\nif (deepEqualIdent(foo, bar)) {\n // deep equal\n}\n```\n\n### Use with chai.js\n\nThis module provides integration with the [chai.js assertion framework](http://chaijs.com/)\n(for Node.js at least).\nEnable the extensions with\n\n    chai.use(require('deep-equal-ident/chai'));\n\nThen you can use either the `expect` or `assert` interface:\n\n```javascript\n// expect\nexpect(foo).to.deep.identically.equal(bar);\nexpect(foo).to.identically.equal(bar);\n\n// assert\nassert.deepEqualIdent(foo, bar);\nassert.NotDeepEqualIdent(foo, bar);\n```\n\n---\n\n### So, what is this really about?\n\nMost deep equality tests (including `_.isEqual`) consider the following\nstructures as equal:\n\n```javascript\nvar a = [1,2,3];\nvar b = [1,2,3];\nvar foo = [a, a];\nvar bar = [a, b];\n_.isEqual(foo , bar): // => true\n```\n\nHere, `foo` contains two reference to the same object, but `bar` contains\nreferences to two different (not identical) objects. `a` and `b` might be itself\nconsidered as equal (they do after all contain the same values), but the\n*structures* of `foo` and `bar` are different.\n\n`deepEqualIdent` will consider these values as not equal:\n\n```javascript\ndeepEqualIdent(foo, bar); // => false\n```\n\nThe following slightly different structures would be considered equal:\n\n```javascript\nvar a = [1,2,3];\nvar b = [1,2,3];\nvar foo = [a, a];\nvar bar = [b, b];\ndeepEqualIdent(foo, bar); // => true\n```\n\n### Why does it matter?\n\nLet's have a look at another procedure to answer that question: *deep cloning*.\nGiven\n\n```javascript\nvar a = [1,2,3];\nvar foo = [a, a];\n```\n\na *good* deep cloning algorithm would recognize that both elements in `foo`\nrefer to the same object and thus would create a single copy of `a`:\n\n```javascript\nvar a_copy = [1,2,3];\nvar foo_copy = [a_copy, a_copy];\n```\n\nThis is desired because we want `foo_copy` behave *exactly* like `foo` when we\nprocess it. I.e. if the first element is mutated, the second element should\nmutate as well:\n\n```javascript\nfoo_copy[0][0] += 1;\nconsole.log(foo_copy); // => [[2,2,3], [2,2,3]]\n```\n\nIf the deep copy algorithm would produce separate copies for each element in `foo`\ninstead\n\n```javascript\nvar a_copy_1 = [1,2,3];\nvar a_copy_2 = [1,2,3];\nvar foo_copy = [a_copy_1, a_copy_2];\n```\n\nthen mutating the first element of `foo_copy` would not produce the same result\nas mutation the first element of `foo`, and thus it would not be an exact copy\nof `foo`.\n\n---\n\nI hope this makes it clearer why considering the identity of objects during\ncomparison is important: To preserve the structural integrity. If two nested\nstructures are said to be equal, they should *behave* exactly the same for all\nintends and purposes.\n\nAnother way to look at it is to visualize the relationship between the values as\ngraphs. Let's change the structure a bit:\n\n```javascript\nvar a = [1,2,3];\nvar b = [1,2,3];\nvar foo = [a, {x: a}];\nvar bar = [a, {x: b}];\n```\n\nGraph representations:\n\n```\n   - foo -        - bar -\n  |       |      |       |\n  v       v      v       v\n  a <--- { }     a      { }\n                         |\n                         v\n                         b\n```\n\nI think this makes it very obvious that the structure of `foo` and `bar` are\ndifferent and thus would produce different results when processed.\n\n### OK, so how did you implement it?\n\nIt's really straightforward. Just like with deep cloning, we have to keep\ntrack of which objects we already encountered in `a` and associate it with the\ncorresponding value in `b`. Interestingly, deep cloning methods that can handle\ncycles are already doing this, but only vertically, not horizontally. It shouldn't\nbe too much effort to modify them to support this out of the box.\n\nThere are a couple of ways to do it, each with its advantages and disadvantages.\nI implemented two of them and choose to build them on top of lodash's `isEqual`\nfunction, since it allows me to pass a callback and utilize all of the other\ncomparison logic that `isEqual` provides.\n\n#### Tags\n\nOne way is to \"tag\" objects we have already seen and associate them with the\ncorresponding other object (creating some kind of bijective relationship). For\nthis I just added a new, not enumerable property to the object and setting the other\nobject as value, e.g.\n\n```javascript\nObject.defineProperty(a, '__<random prop>__', {value: b});\nObject.defineProperty(b, '__<random prop>__', {value: a});\n```\n\nNow whenever we encounter an object (`a1`) that already has the property, we check\nwhether it has a reference to `b1`. We also have to check the other direction,\ni.e. if `b1` refers to `a1`. Overall this allows for the following outcomes:\n\n- `a1` and `b1` not tagged: Not seen before => tag\n- Either `a1` or `b1` not tagged: not equal\n- `a1` tagged but does not refer to `b1`: not equal\n- `b1` tagged but does not refer to `a1`: not equal\n\nIt's important to note that we can't detect equality. While the overall structure\nmight be the same, e.g. we have `[a, a]` and `[b, b]`, `a` and `b` might still be\ndifferent. So we have to let the actual comparison algorithm determine equality\nof these two values.\n\n#### Stack\n\nThe previous solution has the advantage that determining the \"not equality\" is\nquick, but it doesn't work for *immutable* objects. As alternative, we can push\neach of the objects onto a stack and whenever we encounter another object, we\niterate over the stack and check whether it is already contained in the stack.\nThe result is the same as with tags.\n\nThe disadvantage is that performance decreases the more objects have to be\ncompared.\n\n#### Maps\n\nThe solution to the immutability and performance problems could be ES6 `Map`s,\nassuming they are supported they are supported by the environment this code\nruns in.\n\nAn implementation using Maps is included and is used if `global.Map` is\navailable.\n\n### Caveats\n\n`deep-equal-ident` **incorrectly** assumes the following structures to be\nequal:\n\n```javascript\nvar a = [[]];\nvar foo = [a, a[0]];\nvar bar = [a, []];\ndeepEqualIdent(foo, bar); // true\n```\n\nThat's because lodash doesn't traverse deeper into the first element (because\n`foo[0] === bar[0]`, so the algorithm doesn't know about the objects inside\n`foo[0]` (and `bar[0]`) and therefore cannot detect whether they repeat\nelsewhere in the data structure.\n","readmeFilename":"README.md","_id":"deep-equal-ident@1.1.1","_shasum":"06f4b89e53710cd6cea4a7781c7a956642de8dc9","_resolved":"https://registry.npmjs.org/deep-equal-ident/-/deep-equal-ident-1.1.1.tgz","_from":"https://registry.npmjs.org/deep-equal-ident/-/deep-equal-ident-1.1.1.tgz"}